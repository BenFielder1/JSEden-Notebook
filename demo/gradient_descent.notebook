[{"cell_type":"markdown","source":["# Partial Derivative Gradient Descent"]},{"cell_type":"markdown","source":["## Derivitive Idea","","I want to illustrate gradient descent via partial derivatives - inspired by this video https://youtube.com/watch?v=Jd55bul1VHo ","","There are 4 basic types that I want to represent","- Constants","- Variables","- Addition","- Multiplication","","Each of these has slightly different representation types, and different calculations for their derivative. We can represent a constant like this, then defining a value for the expression:"]},{"cell_type":"code","source":["Const is [\"const\", expr];","const3 is Const with expr is 3;"]},{"cell_type":"markdown","source":["We can represent a variable with an expression like this"]},{"cell_type":"code","source":["Var is [\"var\", expr];","varx is Var with expr is \"x\";"]},{"cell_type":"markdown","source":["Note that the Const and Var is just a convenient way of getting a template, we could get exactly the same use without them such as "]},{"cell_type":"code","source":["const4 is [\"const\",4];","vary is [\"var\",\"y\"];"]},{"cell_type":"markdown","source":["But in a minute, I'm going to define derivative and evaluation formulae for each type, so it makes sense (to me at least) to define these as if they were \"classes\", "]},{"cell_type":"markdown","source":["## Base Derivatives","","The derivative of a constant is always 0"]},{"cell_type":"code","source":["ConstDeriv is [\"const\",0];"]},{"cell_type":"markdown","source":["The derivative of a variable is 1, if we're differentiating with respect to that variable, so let's assume we're doing it with respect to x."]},{"cell_type":"code","source":["wrt = \"x\";"]},{"cell_type":"markdown","source":["Now, if we have a variable called x, and we're doing it wrt x, the derivative will be 1, else it will be 0.","The expression will be whatever I pass to the VarDeriv function."]},{"cell_type":"code","source":["VarDeriv is [\"const\",1] if expr[2] == wrt else [\"const\",0];"]},{"cell_type":"markdown","source":["The reason for having [2] there is that we're accessing a list, remember from the previous page that a variable is a list of two objects, such as:"]},{"cell_type":"code","source":["testExpr is [\"var\",\"x\"];"]},{"cell_type":"markdown","source":["In our VarDeriv, we want to access the second element (lists are 1-based not 0-based like arrays in most languages). ","So to get the derivative of testExpr we could say:"]},{"cell_type":"code","source":["testExpr_d is VarDeriv with expr is testExpr;"]},{"cell_type":"markdown","source":["When this next line is run, you'll see the value of testExpr_d on the left."]},{"cell_type":"code","source":["picture1 is [Text(\"Value of testExpr_d: \" // str(testExpr_d),20,50)];"]},{"cell_type":"markdown","source":["Try changing the above definition of testExpr to see value change on the left.","So we can get the derivative for a constant or a variable, but we want the construal to be able to know which is which, so let's write a more general derivative expression:"]},{"cell_type":"code","source":["Deriv is ConstDeriv if expr[1] == \"const\" ","else VarDeriv if expr[1] == \"var\" ","else @;"]},{"cell_type":"markdown","source":["So now we can generalise our expression for testExpr_d:"]},{"cell_type":"code","source":["testExpr_d is Deriv with expr is testExpr;"]},{"cell_type":"markdown","source":["Now we can change between a constant and a variable by changing testExpr - click either of the following definitions to watch it change:"]},{"cell_type":"code","source":["testExpr is [\"const\",5];"]},{"cell_type":"code","source":["testExpr is [\"var\",\"y\"];"]},{"cell_type":"code","source":["testExpr is [\"var\",\"x\"];"]},{"cell_type":"markdown","source":["## Plus Derivatives","","The next thing to define is what happens to the derivative when two expressions are added together.","We can define an addition as a Plus 'object' with two operands; a left side and a right side:"]},{"cell_type":"code","source":["Plus is [\"plus\", left, right];"]},{"cell_type":"markdown","source":["Each side is an expression (or any of our 4 types), so we could express 4 + 5 as:"]},{"cell_type":"code","source":["myplus is [\"plus\", [\"const\",4],[\"const\",5]];"]},{"cell_type":"markdown","source":["Or 3 + x as:"]},{"cell_type":"code","source":["myplus is [\"plus\", [\"const\",3],[\"var\",\"x\"]];"]},{"cell_type":"markdown","source":["The derivative of a plus is just the derivative of each side of the plus:"]},{"cell_type":"code","source":["PlusDeriv is Plus with left is leftDeriv, right is rightDeriv;","leftDeriv is Deriv with expr is expr[2];","rightDeriv is Deriv with expr is expr[3];"]},{"cell_type":"markdown","source":["Now that we know what PlusDeriv, we can add it to our test for Deriv:"]},{"cell_type":"code","source":["Deriv is ConstDeriv if expr[1] == \"const\" ","else VarDeriv if expr[1] == \"var\" ","else PlusDeriv if expr[1] == \"plus\" ","else @;"]},{"cell_type":"markdown","source":["Let's redefine testExpr_d to see what the derivative of myplus is (select one of the myplus alternatives above):"]},{"cell_type":"code","source":["testExpr is myplus;","testExpr_d is Deriv with expr is testExpr;"]},{"cell_type":"markdown","source":["## Evaluation of Expressions","","Let's think about the values of the expressions we have so far...","","### Constants","","The value of a constant is going to be just the constant, so let's have a ConstEval"]},{"cell_type":"code","source":["ConstEval is expr[2];"]},{"cell_type":"markdown","source":["### Variables","","At some point we're going to want to actually assign values to our variables. We could say something like this:"]},{"cell_type":"code","source":["varlist is [\"x\",\"y\",\"z\"];","varvals is [5,3,1];"]},{"cell_type":"markdown","source":["This would represent that we have the three variables: x=5, y=3, z=1","We could even package them into a list which might make things easier later:"]},{"cell_type":"code","source":["vars is [varlist,varvals];"]},{"cell_type":"markdown","source":["So we could evaluate a variable like this:"]},{"cell_type":"code","source":["varx is vars[2][positionInList(\"x\",vars[1])];"]},{"cell_type":"markdown","source":["Or more generally:"]},{"cell_type":"code","source":["varVal is vars[2][positionInList(targetVar,vars[1])];","vary is varVal with targetVar is \"y\";"]},{"cell_type":"markdown","source":["So we can express the evaluation of a variable with this:"]},{"cell_type":"code","source":["VarEval is varVal with targetVar is expr[2];"]},{"cell_type":"markdown","source":["Let's redefine the picture to see an example:"]},{"cell_type":"code","source":["picture1 is [Text(\"testExpr: \" // str(testExpr),20,50),","Text(\"testExpr_d: \" // str(testExpr_d),20,80),","Text(\"testExpr_e: \" // str(testExpr_e),20,110)","];","testExpr is [\"var\",\"x\"];","testExpr_e is VarEval with expr is testExpr;"]},{"cell_type":"code","source":["Eval is VarEval if expr[1] == \"var\" ","else ConstEval if expr[1] == \"const\"","else @;","testExpr_e is Eval with expr is testExpr;"]},{"cell_type":"markdown","source":["Now we can set testExpr to any of the following and see the value update on the left"]},{"cell_type":"code","source":["testExpr is [\"var\",\"y\"];"]},{"cell_type":"markdown","source":["Or a constant value"]},{"cell_type":"code","source":["testExpr is [\"const\",9];"]},{"cell_type":"code","source":["testExpr is [\"var\",\"z\"];"]},{"cell_type":"code","source":["testExpr is [\"const\",42];"]},{"cell_type":"markdown","source":["## Evaluation of Plus","","We can now add an evaluation of plus"]},{"cell_type":"code","source":["PlusEval is (Eval with expr is expr[2]) + (Eval with expr is expr[3]);"]},{"cell_type":"markdown","source":["When we call on PlusEval, we pass it an expression of the form [\"plus\", ob1, ob2], we need to get at ob1 and ob2, so the definition of PlusEval accesses them through expr[2] and expr[3] respectively","We can now extend the Eval definition to include plus:"]},{"cell_type":"code","source":["Eval is VarEval if expr[1] == \"var\" ","else ConstEval if expr[1] == \"const\"","else PlusEval if expr[1] == \"plus\"","else @;"]},{"cell_type":"markdown","source":["Now let's test it:"]},{"cell_type":"code","source":["vars is [[\"x\",\"y\",\"z\"],[10,8,2]];","testExpr is [\"plus\",[\"const\",5],[\"const\",9]];"]},{"cell_type":"code","source":["wrt = \"z\";","testExpr is [\"plus\",[\"const\",10],[\"var\",\"z\"]];"]},{"cell_type":"code","source":["wrt = \"x\";","testExpr is [\"plus\",[\"plus\",[\"const\",10],[\"var\",\"x\"]],[\"var\",\"x\"]];"]},{"cell_type":"markdown","source":["Note that the above nested expression causes some interesting derivative results - but it is correct. We'll think about how we might be able to simplify that later","","In fact, we now have a way of evaluating the derivative, so let's add that to the picture too:"]},{"cell_type":"code","source":["picture1 is [Text(\"testExpr: \" // str(testExpr),20,50),","Text(\"testExpr_d: \" // str(testExpr_d),20,80),","Text(\"testExpr_e: \" // str(testExpr_e),20,110),","Text(\"testExpr_d_e: \" // str(testExpr_d_e),20,140)","];","testExpr_d_e is Eval with expr is testExpr_d;"]},{"cell_type":"markdown","source":["## Multiplication Derivatives","","The final part (as described on the original video) is to define the multiplication rule. This can be done similar to Plus, but with differences in the differentiation and evaluation."]},{"cell_type":"code","source":["Mult is [\"mult\",left,right];"]},{"cell_type":"markdown","source":["Each side is an expression (or any of our 4 types), so we could express 4 * 5 as:"]},{"cell_type":"code","source":["mymult is [\"mult\",[\"const\",4],[\"const\",5]];"]},{"cell_type":"markdown","source":["Or 3 * x as:"]},{"cell_type":"code","source":["mymult is [\"mult\",[\"const\",3],[\"var\",\"x\"]];"]},{"cell_type":"markdown","source":["The derivative of multiplication has a different rule:"]},{"cell_type":"code","source":["MultDeriv is Plus with left is leftMultDeriv, right is rightMultDeriv;","leftMultDeriv is Mult with left is (Deriv with expr is expr[2]), ","right is expr[3];","rightMultDeriv is Mult with left is expr[2],","right is (Deriv with expr is expr[3]);"]},{"cell_type":"markdown","source":["Now we can add the MultDeriv to our Deriv definition:"]},{"cell_type":"code","source":["Deriv is ConstDeriv if expr[1] == \"const\" ","else VarDeriv if expr[1] == \"var\" ","else PlusDeriv if expr[1] == \"plus\" ","else MultDeriv if expr[1] == \"mult\"","else @;"]},{"cell_type":"markdown","source":["Finally, there's the evaluation of multiplication:"]},{"cell_type":"code","source":["MultEval is (Eval with expr is expr[2]) * (Eval with expr is expr[3]);"]},{"cell_type":"markdown","source":["and then add it to the Eval definition:"]},{"cell_type":"code","source":["Eval is VarEval if expr[1] == \"var\" ","else ConstEval if expr[1] == \"const\"","else PlusEval if expr[1] == \"plus\"","else MultEval if expr[1] == \"mult\"","else @;"]},{"cell_type":"markdown","source":["Let's do a test now:"]},{"cell_type":"code","source":["testExpr is [\"mult\",[\"const\",8],[\"const\",7]];"]},{"cell_type":"code","source":["testExpr is [\"mult\",[\"const\",3],[\"var\",\"x\"]];"]},{"cell_type":"code","source":["testExpr is [\"mult\",[\"var\",\"x\"],[\"var\",\"x\"]];"]},{"cell_type":"markdown","source":["## Simplifying Expressions","","The main part of the Deriv function is described like this (as previously described for Deriv)"]},{"cell_type":"code","source":["Deriv_main is ConstDeriv if expr[1] == \"const\"","else VarDeriv if expr[1] == \"var\" ","else PlusDeriv if expr[1] == \"plus\" ","else MultDeriv if expr[1] == \"mult\"","else @;"]},{"cell_type":"markdown","source":["but now everywhere that we've previously said Deriv, we'd like to simplify it:"]},{"cell_type":"code","source":["Deriv is Simpler with expr is Deriv_main;","expr is testExpr;","Simpler is MultSimpler if (expr[1] == \"mult\") else ","PlusSimpler if (expr[1] == \"plus\") else expr;","MultSimpler is expr[2] if (expr[3][1] == \"const\" && expr[3][2] == 1)","else expr[3] if (expr[2][1] == \"const\" && expr[2][2] == 1) else ","[\"const\",0] if (expr[2][1] == \"const\" && expr[2][2] == 0 || ","expr[3][1] == \"const\" && expr[3][2] == 0) else","expr;"]},{"cell_type":"code","source":["PlusSimpler is expr[2] if (expr[3][1] == \"const\" && expr[3][2] == 0) ","else expr[3] if (expr[2][1] == \"const\" && expr[2][2] == 0) else expr;"]},{"cell_type":"code","source":["testExpr_simpler is Simpler with expr is testExpr;","testExpr = [\"mult\",[\"mult\",[\"var\",\"x\"],[\"const\",2]],[\"var\",\"x\"]];","testExpr = [\"plus\",[\"var\",\"x\"],[\"const\",0]];","testExpr = [\"mult\",[\"mult\",[\"var\",\"x\"],[\"var\",\"x\"]],[\"const\",2]];","testMult is MultSimpler with expr is testExpr;","testExpr_d is Deriv;"]},{"cell_type":"markdown","source":["For some reason I also need to redefine MultDeriv from the previous page (I thought it would naturally happen via Deriv, but apparently not):"]},{"cell_type":"code","source":["MultDeriv is Plus with left is ","(Simpler with expr is leftMultDeriv), ","right is (Simpler with expr is rightMultDeriv);"]},{"cell_type":"markdown","source":["## Let's Draw a Graph","","Now let's see if we can illustrate the deriviatives with a graph","First let's keep the previous labels in a debugLabels observable, so we can more easily refer to them in the picture:"]},{"cell_type":"code","source":["debugLabels is [Text(\"testExpr: \" // str(testExpr),20,50),","Text(\"testExpr_d: \" // str(testExpr_d),20,80),","Text(\"testExpr_e: \" // str(testExpr_e),20,110),","Text(\"testExpr_d_e: \" // str(testExpr_d_e),20,140)","];","","picture1 is [debugLabels];"]},{"cell_type":"markdown","source":["We'll think about a graph of a function (x-4)^2 + (x-3)^3","We can build it up in various parts:"]},{"cell_type":"code","source":["xsq is [\"mult\",[\"var\",\"x\"],[\"var\",\"x\"]];","xlinear is [\"var\",\"x\"];","xtimesminus4 is [\"mult\",[\"var\",\"x\"],[\"const\",-4]];","xminus4 is [\"plus\",[\"var\",\"x\"],[\"const\",-4]];","xminus3 is [\"plus\",[\"var\",\"x\"],[\"const\",-3]];","xminus4sq is [\"mult\",xminus4,xminus4];","xminus3cube is [\"mult\",[\"mult\",xminus3,xminus3],xminus3]; ","testExpr is xlinear;","testExpr is xminus4sq;","testExpr is [\"plus\",xminus4sq,xminus3cube];"]},{"cell_type":"markdown","source":["## Drawing the Graph","","I want the graph to start at a particular position:"]},{"cell_type":"code","source":["xoffset = 30;","yoffset is book_height*3/4;"]},{"cell_type":"markdown","source":["The x axis should extend for most of the picture, but centred, so deduct twice the xoffset"]},{"cell_type":"code","source":["xaxiswidth is book_width/2 - (xoffset*2);"]},{"cell_type":"markdown","source":["Define the line using the above values:"]},{"cell_type":"code","source":["xaxisline is Line(xoffset,yoffset,xoffset+xaxiswidth,yoffset,\"black\");"]},{"cell_type":"markdown","source":["Set inital values for xmax and ymax (the limits of each axis)"]},{"cell_type":"code","source":["xmax = 20;","ymax = 160;"]},{"cell_type":"markdown","source":["The spacing of the tick marks"]},{"cell_type":"code","source":["xtickinterval = 2;","ytickinterval = 20;"]},{"cell_type":"markdown","source":["The actual height of the graph"]},{"cell_type":"code","source":["yaxisheight is yoffset - (book_height /4);"]},{"cell_type":"markdown","source":["Define the yaxis line"]},{"cell_type":"code","source":["yaxisline is Line(xoffset,yoffset,xoffset,yoffset - yaxisheight, \"black\");"]},{"cell_type":"markdown","source":["Define the xtickpos, originally expressed in terms of graph distance ( /  units, but needs to be converted to actual pixels to draw on the canvas picture"]},{"cell_type":"code","source":["xtickpos is graphXToCanvasX with graphX is xtickinterval*i;"]},{"cell_type":"markdown","source":["This is a  utility function to convert from graph X co-ordinates to canvas co-ordiates"]},{"cell_type":"code","source":["graphXToCanvasX is (xaxiswidth/xmax)*graphX+xoffset;"]},{"cell_type":"markdown","source":["Define a single tick along the x axis"]},{"cell_type":"code","source":["xtick is Line(xtickpos,yoffset-5,xtickpos,yoffset+5,\"black\");"]},{"cell_type":"markdown","source":["Define multiple ticks along the x axis (as many as will fit)"]},{"cell_type":"code","source":["xticks is xtick with i is 0..(int(xmax/xtickinterval));"]},{"cell_type":"markdown","source":["Add the ticks and axis lines to the picture"]},{"cell_type":"code","source":["picture1 is [debugLabels, xaxisline,xticks,yticks,yaxisline];"]},{"cell_type":"markdown","source":["Define ytick positions (as with x), with a utility function to convert from graph Y co-ordinates to canvas co-ordinates"]},{"cell_type":"code","source":["ytickpos is graphYToCanvasY with graphY is 20 * i;","graphYToCanvasY is yoffset - (yaxisheight/ymax)*graphY;"]},{"cell_type":"markdown","source":["Define the tick line"]},{"cell_type":"code","source":["ytick is Line(xoffset-5,ytickpos,xoffset+5,ytickpos,\"black\");"]},{"cell_type":"markdown","source":["Define as many tick lines up the y access (as many as will fit)"]},{"cell_type":"code","source":["yticks is ytick with i is 0..(int(ymax/ytickinterval));"]},{"cell_type":"markdown","source":["Define a dot, and place it at a particular test position (using the utility converter)"]},{"cell_type":"code","source":["colour is \"green\";","dotsize = 5;","dot is Circle(dotx,doty,dotsize,colour);","dotx is graphXToCanvasX with graphX is 20;","doty is graphYToCanvasY with graphY is 20;"]},{"cell_type":"markdown","source":["Add a label so we know what co-ordinate the mouse is pointing at"]},{"cell_type":"code","source":["mouseXLabel is Text(\"MouseXPos: \" // str(mouseXcoord),20,170);"]},{"cell_type":"markdown","source":["Calculate the Xcoord (graph coordinates) that the mouse is pointing to"]},{"cell_type":"code","source":["mouseXcoord is canvasXToGraphX with canvasX is mouseX;"]},{"cell_type":"markdown","source":["Utility function to convert from canvas position to graph co-ordinate"]},{"cell_type":"code","source":["canvasXToGraphX is xmax*(canvasX-xoffset)/xaxiswidth;"]},{"cell_type":"markdown","source":["Add dot to the picture"]},{"cell_type":"code","source":["picture1 is [debugLabels, xaxisline,xticks,yticks,yaxisline,dot,mouseXLabel];"]},{"cell_type":"markdown","source":["Ensure that the variable we evaluate (via Eval) is always using the mouseXcoord as the value of the x variable"]},{"cell_type":"code","source":["vars is [[\"x\"],[mouseXcoord]];","dotx is graphXToCanvasX with graphX is mouseXcoord;","doty is graphYToCanvasY with graphY is (Eval with expr is testExpr);"]},{"cell_type":"markdown","source":["Draw some dots to show the basic outline of the function"]},{"cell_type":"code","source":["graphdots is dot with mouseXcoord is 0..(xmax/100)..xmax, colour is \"red\", dotsize is 2;"]},{"cell_type":"markdown","source":["Add the graphdots to the picture"]},{"cell_type":"code","source":["picture1 is [debugLabels, xaxisline,xticks,yticks,yaxisline,dot,graphdots,mouseXLabel];"]},{"cell_type":"markdown","source":["## Making the Expression more Compact","","Eventually, we want this to illustrate gradient descent by being able to edit coefficients","It's a bit unweildy to manipulate and interpret these functions in their current 'prefix' mode. It would be great to convert from prefix to infix. I'll probably have to do this like a tree. http://www.cs.man.ac.uk/~pjj/cs212/fix.html but first let's see if we can simplify the const/var types","Although it made it easier to think about the derivation of the derivitives, I don't like the fact that I have to say \"const\" and \"var\" (during testing, I kept accidentally saying something like [\"const\",\"x\"] or [\"var\",42] and wondering why it didn't work. I could automatically detect whether something is a number or not, so I don't really need those.","Although I started this Construal by defining Const and Var, I never really used them (I should have, it would have made my next change backwards compatible - never mind, let's redefine things:"]},{"cell_type":"code","source":["Const is expr;","const3 is Const with expr is 3;","Var is expr;","varx is Var with expr is \"x\";"]},{"cell_type":"markdown","source":["Note now Const and Var have exactly the same construction, I can now just say:"]},{"cell_type":"code","source":["vary is \"y\";","const4 is 4;"]},{"cell_type":"markdown","source":["The Base derivitives no longer need their types:"]},{"cell_type":"code","source":["ConstDeriv is 0;","VarDeriv is 1 if expr == wrt else 0;"]},{"cell_type":"markdown","source":["The Base evaluation functions need to return the actual values:"]},{"cell_type":"code","source":["ConstEval is expr;","VarEval is varVal with targetVar is expr;"]},{"cell_type":"markdown","source":["But now we need a way of choosing whether to evaluate a scalar observable as a number or a variable. We'll say that it's a variable if it's a string:"]},{"cell_type":"code","source":["Deriv_main is VarDeriv if isString(expr)","else ConstDeriv if (expr# == @)","else PlusDeriv if expr[1] == \"plus\" ","else MultDeriv if expr[1] == \"mult\"","else @;","Eval is VarEval if isString(expr)","else ConstEval if (expr# == @)","else PlusEval if expr[1] == \"plus\"","else MultEval if expr[1] == \"mult\"","else @;"]},{"cell_type":"markdown","source":["So now we can just define testExpr in terms of it's consituent parts, as we did a couple of pages ago:"]},{"cell_type":"code","source":["xsq is [\"mult\",\"x\",\"x\"];","xlinear is \"x\";","xtimesminus4 is [\"mult\",\"x\",-4];","xminus4 is [\"plus\",\"x\",-4];","xminus3 is [\"plus\",\"x\",-3];","xminus4sq is [\"mult\",xminus4,xminus4];","xminus3cube is [\"mult\",[\"mult\",xminus3,xminus3],xminus3]; ","testExpr is xlinear;","testExpr is xminus4sq;","testExpr is [\"plus\",xminus4sq,xminus3cube];"]},{"cell_type":"markdown","source":["### Making Operations more Compact:","","While we're thinking of simplifying things, it might be more readable to replace \"mult\" with \"*\" and \"plus\" with \"+\", so the target would be to make this work:"]},{"cell_type":"code","source":["xsq is [\"*\",\"x\",\"x\"];","xlinear is \"x\";","xtimesminus4 is [\"*\",\"x\",-4];","xminus4 is [\"+\",\"x\",-4];","xminus3 is [\"+\",\"x\",-3];","xminus4sq is [\"*\",xminus4,xminus4];","xminus3cube is [\"*\",[\"*\",xminus3,xminus3],xminus3]; ","testExpr is xlinear;","testExpr is xminus4sq;","testExpr is [\"+\",xminus4sq,xminus3cube];"]},{"cell_type":"markdown","source":["Redefining operators:"]},{"cell_type":"code","source":["Plus is [\"+\",left,right];","Mult is [\"*\",left,right];"]},{"cell_type":"markdown","source":["Choosing the correct Deriv and Eval functions:"]},{"cell_type":"code","source":["Deriv_main is VarDeriv if isString(expr)","else ConstDeriv if (expr# == @)","else PlusDeriv if expr[1] == \"+\" ","else MultDeriv if expr[1] == \"*\"","else @;","Eval is VarEval if isString(expr)","else ConstEval if (expr# == @)","else PlusEval if expr[1] == \"+\"","else MultEval if expr[1] == \"*\"","else @;"]},{"cell_type":"markdown","source":["## Simplifying Operations","","The expression of the expressions (!), is now slighty more compact, but there are still some strange things in the derivative. For instance, when using:"]},{"cell_type":"code","source":["testExpr is [\"+\",xminus4sq,xminus3cube];"]},{"cell_type":"markdown","source":["you can see there are things like [+\",1,0]. Of course this should simplify to just 1, but then that would also mean the multiplication that surrounds it should also recognise that multiplying by 1 doesn't need to happen (the 'identity' element of multiplication). We already defined that part in a previous page, but can we just add constants together to replace them with a constant rather than a plus operation?"]},{"cell_type":"code","source":["Plus is left+right if (left# == @ && right# == @) ","else [\"+\",left,right];"]},{"cell_type":"markdown","source":["At which point I discover the Simplify part isn't working anymore anyway (something to do with the compactness changes we made on the last page). We can reinstate it with this:"]},{"cell_type":"code","source":["Simpler is MultSimpler if (expr[1] == \"*\") else ","PlusSimpler if (expr[1] == \"+\") else expr;","MultSimpler is expr[2] if (expr[3] == 1)","else expr[3] if (expr[2] == 1) else ","0 if (expr[2] == 0 || expr[3] == 0) else","expr;"]},{"cell_type":"markdown","source":["We can also change Mult in case there are situations where there are two constants occuring:"]},{"cell_type":"code","source":["Mult is left*right if (left# == @ && right# == @) ","else [\"*\",left,right];"]},{"cell_type":"markdown","source":["The deriviative of testExpr is now given by this expression (just so I can display it in the book):"]},{"cell_type":"code","source":["strtestExpr_d is str(testExpr_d);"]},{"cell_type":"markdown","source":["Of course, it would be nice if it was made even simpler, but as we only have the Plus and Mult operations, the final parts that involve multiplying together (x-3) wouldn't be able to be simplified (we'd need an exp function, which would have to be redefined as it's own derivative - maybe later!).","However, early on in that expression, there is a part where it is effectively (x-4) + (x-4) - it would be good to recognise this and change it to 2 * (x-4)"]},{"cell_type":"code","source":["Plus is left+right if (left# == @ && right# == @)","else [\"*\",2,left] if left == right","else [\"+\",left,right];"]},{"cell_type":"markdown","source":["## Visualising the Expression","","We have some prefix-style ways of notating expressions, these define each expression as a tree. We could visualise that tree, showing how the derivatives are calculated.","","First we need some basic numbers that we can use to position and scale the tree"]},{"cell_type":"code","source":["originx is book_width/4;","originy = 20;","breadth = 277;","branchfact = 0.5;","depthfact = 0.2256;","depthHeight = 46;"]},{"cell_type":"markdown","source":["k is the index of the child"]},{"cell_type":"code","source":["k = 0;"]},{"cell_type":"markdown","source":["Each node is a parent with a left and right child and a branch line that points back to it's parent"]},{"cell_type":"code","source":["node is [lnode,","Circle(originx+x,ys,4,\"black\"),Text(k,originx+x,ys),","rnode,","branchl","];"]},{"cell_type":"markdown","source":["Basic mathematical expressions - the depth of any particular node is calculated based on the log of it's node number k"]},{"cell_type":"code","source":["d is floor(log(k+1,2));"]},{"cell_type":"markdown","source":["The parent ID of the node is just half of the current node's ID (as the branch factor is 2)"]},{"cell_type":"code","source":["parent is floor((k - 1) / 2);"]},{"cell_type":"markdown","source":["The y position of a particular node is just based on the node's depth in the tree"]},{"cell_type":"code","source":["ys is originy+depthHeight*d;"]},{"cell_type":"markdown","source":["The x position of a node's parent can be calculated like this:"]},{"cell_type":"code","source":["parentx is (x with k is parent);","parenty is (ys with d is d - 1);"]},{"cell_type":"markdown","source":["The branch line is just a line from the current x,y position to the "]},{"cell_type":"code","source":["branchl is Line(originx+x,ys, originx+ parentx,parenty,\"#BBBBBB\");"]},{"cell_type":"markdown","source":["At the moment, our only criteria for which nodes should be drawn is that the tree should have 5 levels"]},{"cell_type":"code","source":["depth = 5;"]},{"cell_type":"markdown","source":["So if the depth of a particular node is not smaller than depth, set the node's children to be \\@ which will stop the recursion"]},{"cell_type":"code","source":["node_d is node if d < depth else @;"]},{"cell_type":"markdown","source":["lnode and rnode are the node's children (if allowed by the above definition)"]},{"cell_type":"code","source":["lnode is node_d with k is k*2 +1;","rnode is node_d with k is k*2 +2;"]},{"cell_type":"markdown","source":["The x position of a node is 0 at the first level, or it's the parent's position plus the node's difference (i.e., wheter it should be drawn to the left or right of the node"]},{"cell_type":"code","source":["x is 0 if k == 0 else parentx + posxdiff;"]},{"cell_type":"markdown","source":["The difference of this node is calculated based on whether it's the odd or even child. branchfact is defined above as < 1, so raising it to the pow of the depth (d - 1) ensures that lower branches are drawn closer together to fit them in."]},{"cell_type":"code","source":["posxdiff is  (k % 2 -0.5)*-1*breadth*pow(branchfact,d-1);"]},{"cell_type":"markdown","source":["Add the root node to the picture (which will bring with it all recursive children)"]},{"cell_type":"code","source":["picture1 is [node];"]},{"cell_type":"markdown","source":["## Pruning the Tree","","As we saw on the previous page we prune the tree by ensuring node left or right is undefined if we don't want that node:"]},{"cell_type":"code","source":["node_d is node if d < depth else @;"]},{"cell_type":"markdown","source":["We could be more specific here for instance to stop nodes 3 or below we could say:"]},{"cell_type":"code","source":["node_d is node if (d < depth && k != 3) else @;"]},{"cell_type":"markdown","source":["Or possible more naturally:"]},{"cell_type":"code","source":["node_d is @ if (d >= depth || k == 3) else node;"]},{"cell_type":"markdown","source":["So now we have a criteria for choosing which nodes should be shown. It would be good to be able to address the nodes:","One way might be to have binary counting, starting at 1 at the top, then adding a 0 to the end every time there is a left turn or a 1 at the end when there's a right turn. Then a node could be addressed by traversing the data? Effectively I think we already have that if we add 1 to every k."]},{"cell_type":"code","source":["node_d is @ if (d >= depth) else node;","","node is [lnode,","Circle(originx+x,ys,4,\"black\"),Text(k+1,originx+x,ys,\"red\"),","rnode,","branchl","];"]},{"cell_type":"markdown","source":["It would be a start if we could just add labels to every node. Actually, note that with the above definition of node, the Text isn't always shown on top of the lines. It would be cleaner if I took the text out of the node definition and added them on afterwards (in fact, why don't I do that for all visuals?!):"]},{"cell_type":"code","source":["branches is branchl with k is 0..30;","nodecircles is Circle(originx + x, ys, 4, \"cyan\") with k is 0..30;","mytexts is Text(k+1, originx+x,ys,\"red\") with k is 0..30;","picture1 is [branches,nodecircles,mytexts];","node is [lnode,rnode];","node is @;"]},{"cell_type":"markdown","source":["So it looks like I don't need the node at all, but I'll still need some mechanism like it in order to decide which nodes to show. Rather than having each of the above as a \" k is 0..30 \". I could probably do something better by having a list of the nodes that I want: "]},{"cell_type":"code","source":["kwanted = k_i with k_i in 0..30;","branches is branchl with k in kwanted;","nodecircles is Circle(originx + x, ys, 4, \"black\") with k in kwanted;","mytexts is Text(k+1, originx+x,ys,\"red\") with k in kwanted;"]},{"cell_type":"markdown","source":["Then I can just prune kwanted (this takes a couple of seconds because everything is redrawn, so I put it in an action so it isn't run automatically):"]},{"cell_type":"code","source":["action removeFromArray{","kwanted[3] = @;","}"]},{"cell_type":"markdown","source":["But for now let's keep them all..."]},{"cell_type":"code","source":["kwanted = k_i with k_i in 0..30;"]},{"cell_type":"markdown","source":["## A Binary Path","","It would be useful to be able to navigate around the tree structure. It might be possible to use binary as a way of homing in on the correct node.","There isn't a native way of converting a number to binary, so let's make one.","This bit isn't strictly necessary, the logic is correct, but the method isn't used","Assuming myv is the value we want to convert. The number of bits used can be expressed as:"]},{"cell_type":"code","source":["numBinaryDigits is ceil(log(myv+1,2));"]},{"cell_type":"markdown","source":["To convert to binary, we need to get the quotient for each iteration (see https://www.rapidtables.com/convert/number/decimal-to-binary.html). For the first step (the LSB), the quotient is the original value. For other steps, the quotient is half of the previous quotient."]},{"cell_type":"code","source":["qt is myv if step == 0 else floor((qt with step is step -1)/2);"]},{"cell_type":"markdown","source":["Start at step 0"]},{"cell_type":"code","source":["step = 0;"]},{"cell_type":"markdown","source":["The value of each bit is whether the quotient is odd or even."]},{"cell_type":"code","source":["rem is qt % 2;"]},{"cell_type":"markdown","source":["The binary conversion is then performed by repeating this process for each of the digits required. We reverse the binaryk because the step sequence generates the LSB first."]},{"cell_type":"code","source":["binary is reverse(rem with step is 0..(numBinaryDigits-1));"]},{"cell_type":"markdown","source":["So if we want a particular target, we can get the binary value like this:"]},{"cell_type":"code","source":["targetNode = 17;","mybinary is binary with myv is targetNode;"]},{"cell_type":"markdown","source":["Let's see if changing the text to binary helps us see how to get through the tree:"]},{"cell_type":"code","source":["binaryk is binary with myv is (k+1);","mytexts is Text(str(binaryk) // \"(\" // (k+1) // \")\", originx+x,ys,\"red\") "," with k is 0..30;"]},{"cell_type":"markdown","source":["It's a bit hard to see towards the bottom, but it's fairly clear what's happening. If starting at the root node with 1, we can see that every time the tree turns left, there's a 0 added to the LSB, and every time the tree turns right, there's a 1 added to the LSB. Let's go back to just the decimal numbers so we can test this."]},{"cell_type":"code","source":["mytexts is Text((k+1), originx+x,ys,\"red\") "," with k is 0..30;"]},{"cell_type":"markdown","source":["If we start at 1 and want to go to 2, we turn left. We need a way of expressing this. We can immediately ignore the MSB. "]},{"cell_type":"code","source":["target = 28;","mypath is (binary with myv is target);","mypath_i is mypath[i];","mypath_without_MSB is mypath_i with i is 2..(mypath#);","pathPart is \"left\" if mypath[i] == 0 else \"right\";","pathInstructions is pathPart with i is 2..(mypath#);"]},{"cell_type":"markdown","source":["## Back to the Expression Tree","","Eventually the tree will be used to display expressions created based on the derivative, but first let's start with a very basic expression tree."]},{"cell_type":"code","source":["testExpr is xminus4sq;","testExpr = [\"*\",[\"+\",\"x\",-4],[\"+\",\"x\",-4]];"]},{"cell_type":"markdown","source":["xminus4sq has a root and two children. Each of these children has two children. So it can be expressed in 7 nodes.","Eventually, we'll have an automatic way of deciding which nodes should be displayed, but first lets change the depth to only show those nodes."]},{"cell_type":"code","source":["depth = 2;","maxnodes = 10;"]},{"cell_type":"markdown","source":["Then we can limit the branches, nodecircles and mytexts to only be k betwen 0 and maxnodes - 1"]},{"cell_type":"code","source":["branches is branchl with k is 0..(maxnodes - 1);","nodecircles is Circle(originx + x, ys, 4, \"cyan\") with k is 0..(maxnodes - 1);","mytexts is Text(label, originx+x,ys+10,16,\"red\",\"middle centre\") with k is 0..(maxnodes - 1);"]},{"cell_type":"markdown","source":["There are undefined branches below, that don't need to be represented, we can automatically generate these below.","","We'll define subExpr to be the combination of the below subtree. First we'll get the root expression and display the whole thing. Then each node can refer to the parent"]},{"cell_type":"code","source":["subExpr is (testExpr) if k == 0 else parentExpr[childNum];","label is str(subExpr);","parentExpr is subExpr with k is (floor((k - 1) / 2));","childNum is ((k + 1) % 2)+2;"]},{"cell_type":"markdown","source":["Now we can refer to any sub expression with the following code:","For target, 0 will refer to the root"]},{"cell_type":"code","source":["target = 0;","targetExpr is subExpr with k is target;"]},{"cell_type":"markdown","source":["We can also just take the first element of each subExpr to just show the operation/value at that node. If the subExpr is a list, we just want the first operation. If it's not a list, we want the actual value. Note that technically strings (representing variables are lists, but as they are only single character names,  it doesn't really matter."]},{"cell_type":"code","source":["nodeValue is subExpr[1] if subExpr# != @ else subExpr;","label is nodeValue;"]},{"cell_type":"markdown","source":["We can remove the unnecessary 'undefined' nodes by redefining branchl, nodecircles and mytexts based on whether there is a label for that node:"]},{"cell_type":"code","source":["branchl is Line(originx+x,ys, originx+ parentx,parenty,\"#BBBBBB\") if nodeValue else @;","nodecircle is Circle(originx +x,ys,4,\"cyan\") if nodeValue else @;","nodecircles is nodecircle with k is 0..(maxnodes-1);","mytext is Text(label,originx+x,ys+10,20,\"red\",\"middle centre\") if nodeValue else @;","mytexts is mytext with k is 0..(maxnodes-1);"]},{"cell_type":"markdown","source":["At the moment, we have labels that are based on the parent node. But what if we wanted to have another label that was based on the children of each node?"]},{"cell_type":"code","source":["idtext is Text(k,originx + x, ys - 10,12,\"green\",\"middle centre\") if nodeValue else @;","idtexts is idtext with k is 0..(maxnodes-1);","picture is [branches,nodecircles,mytexts,idtexts];"]},{"cell_type":"markdown","source":["We can find the children of each node using the formula on the previous page:"]},{"cell_type":"code","source":["parent is floor((k - 1) / 2);"]},{"cell_type":"markdown","source":["By rearranging this expression (and by observing the binary pattern on the previous page), we can derive the children as:"]},{"cell_type":"code","source":["leftChild is (k+1)*2-1;","rightChild is (k+1)*2;","k = 0;"]},{"cell_type":"markdown","source":["I'd like to get the infix representation (rather than prefix as the testExpr currently is). To do this, I'm going to need to make an infixLabel for each node which is based on it's children","This will be recursive, so it's important that it stops, so the first stage is a single level-version"]},{"cell_type":"code","source":["leftInfix is infix with k is leftChild;","rightInfix is infix with k is rightChild;","infix is (leftInfix if (nodeValue with k is leftChild) != @ else \"\")","// nodeValue // ","(rightInfix if (nodeValue with k is leftChild) != @ else \"\");"]},{"cell_type":"markdown","source":["This isn't bad, although the expressions don't quite make sense of precedence, on the next page we'll think about making it more correct:"]},{"cell_type":"code","source":["label is infix;"]},{"cell_type":"markdown","source":["## Correcting the Expressions","","The first thing we could do is just add brackets to everything:"]},{"cell_type":"code","source":["infix is \"(\"//(leftInfix if (nodeValue with k is leftChild) != @ else \"\")","// nodeValue // ","(rightInfix if (nodeValue with k is leftChild) != @ else \"\") // \")\";"]},{"cell_type":"markdown","source":["Which is technically correct, but looks weird!","We could exempt the leaf nodes from the brackets:"]},{"cell_type":"code","source":["leftbracket is \"(\" if subExpr# > 1 else \"\";","rightbracket is \")\" if subExpr# > 1 else \"\";","infix is leftbracket//(leftInfix if (nodeValue with k is leftChild) != @ else \"\")","// nodeValue // ","(rightInfix if (nodeValue with k is leftChild) != @ else \"\") // rightbracket;"]},{"cell_type":"markdown","source":["Although it would look better if there were no surrounding brackets for each expression, so for instance the expression on node 2 doesn't need brackets, only when it appears as part of a larger expression (on node 0)."]},{"cell_type":"code","source":["infix is (leftInfix if (nodeValue with k is leftChild) != @ else \"\")","// nodeValue // ","(rightInfix if (nodeValue with k is leftChild) != @ else \"\");","","leftInfix is (leftbracket // infix // rightbracket) with k is leftChild;","rightInfix is (leftbracket // infix // rightbracket) with k is rightChild;"]},{"cell_type":"markdown","source":["It still looks a bit strange having things like x+-4, so it would be good to introduce a minus operator. For the purposes of differentiating, we'll keep it as a plus, but for purposes of display we can replace those with a negative:"]},{"cell_type":"code","source":["leftInfix_Or_Empty is (leftInfix if (nodeValue with k is leftChild) != @ else \"\");","rightInfix_Or_Empty is (rightInfix if (nodeValue with k is leftChild) != @ else \"\");","","infix is (leftInfix_Or_Empty // nodeValue // rightInfix_Or_Empty)","if not(rightInfix_Or_Empty < 0 && nodeValue == \"+\")","else (leftInfix_Or_Empty // rightInfix_Or_Empty);"]},{"cell_type":"markdown","source":["Other Oddities","There might be other oddities, for instance if we set:"]},{"cell_type":"code","source":["testExpr = [\"*\",[\"+\",\"x\",-3],[\"+\",\"x\",-4]];","ymax = 1000;"]},{"cell_type":"markdown","source":["TODO: Implement associativity / communitivity rules.","Maybe we could temporarily combine \"+\" operations for formatting purposes.?"]},{"cell_type":"markdown","source":["## Removing the Tree","","We addressing the root node, we should be able to get the result of converting our usual prefix expressions to an infix expression without needing to look at the tree - this will save a bit of resources (although we might need to remember that there is still a limit on the number of nodes, so we shouldn't make our expressions too complex!)","Let's go back to the graph view:"]},{"cell_type":"code","source":["picture1 is [debugLabels, xaxisline,xticks,yticks,yaxisline,dot,graphdots,mouseXLabel];"]},{"cell_type":"markdown","source":["and go back to a quadratic equation:"]},{"cell_type":"code","source":["testExpr = [\"*\",[\"+\",\"x\",-3],[\"+\",\"x\",-4]];"]},{"cell_type":"markdown","source":["We can now just get the full infix expression by saying:"]},{"cell_type":"code","source":["k = 0;","simplifiedExpression is (infix with k is 0);"]},{"cell_type":"markdown","source":["Let's change debugLabels to show the infix expression:"]},{"cell_type":"code","source":["debugLabels is [Text(\"testExpr: \" // str(simplifiedExpression with testExpr is testExpr),20,50),","Text(\"testExpr_d: \" // str(simplifiedExpression with testExpr is testExpr_d),20,80),","Text(\"testExpr_e: \" // str(testExpr_e),20,110),","Text(\"testExpr_d_e: \" // str(testExpr_d_e),20,140)];","","testExpr = [\"*\",-1,[\"*\",[\"+\",3,[\"*\",\"x\",-5]],[\"+\",\"x\",-4]]];"]},{"cell_type":"markdown","source":["## Adding Functions","","Let's define some more derivatives:","Although it's out of scope to define all functions, some extra basic functions can be defined:","So far, every operator has been binary, but sin and cos are both unary. This might cause confusion when parsing. It doesn't really matter what the second argument is, so let's set it to 1:"]},{"cell_type":"code","source":["Sin is [\"sin\",expr,1];"]},{"cell_type":"markdown","source":["When evaluating, we can evaluate it with just the sin function (recursively evaluating any other part of the expression): "]},{"cell_type":"code","source":["SinEval is sin(Eval with expr is expr[2]);"]},{"cell_type":"markdown","source":["Similarly for the cos function:"]},{"cell_type":"code","source":["Cos is [\"cos\",expr,1];","CosEval is cos(Eval with expr is expr[2]);"]},{"cell_type":"markdown","source":["The derivative of sin x is cos x, but if there is a multiple, such as sin (2*x), it would become 2sin(2*x), this definition checks if there is a multiple, and if so, multiplies the returned cos by the multiplier"]},{"cell_type":"code","source":["SinDeriv is [\"*\",expr[2][3],[\"cos\",expr[2],1]]","if(expr[2][2] == wrt) else","[\"*\", expr[2][2],[\"cos\",expr[2],1]] ","if(expr[2][3] == wrt)","else","[\"cos\",expr[2],1];"]},{"cell_type":"markdown","source":["The derivative of cos x is -sinx, so the default is to return a * object. However, as above, multiples are dealt with:"]},{"cell_type":"code","source":["CosDeriv is [\"*\",-1,[\"*\",expr[2][3],[\"sin\",expr[2],1]]]","if(expr[2][2] == wrt) else","[\"*\",-1,[\"*\", expr[2][2],[\"sin\",expr[2],1]]] ","if(expr[2][3] == wrt)","else","[\"*\",-1,[\"sin\",expr[2]],1];","Deriv_main is ","VarDeriv if isString(expr)","else ConstDeriv if (expr# == @)","else PlusDeriv if expr[1] == \"+\" ","else MultDeriv if expr[1] == \"*\"","else SinDeriv if expr[1] == \"sin\"","else CosDeriv if expr[1] == \"cos\"","else @;","Eval is VarEval if isString(expr)","else ConstEval if (expr# == @)","else PlusEval if expr[1] == \"+\"","else MultEval if expr[1] == \"*\"","else SinEval if expr[1] == \"sin\"","else CosEval if expr[1] == \"cos\"","else @;","testExpr = [\"+\",2,[\"cos\",[\"*\",2,\"x\"],1]];","testExpr = [\"+\",2,[\"sin\",\"x\",1]];","ymax = 4;","xmax = 360;"]},{"cell_type":"code","source":["testExpr = [\"+\",2,[\"cos\",[\"*\",2,\"x\"],1]];"]},{"cell_type":"code","source":["testExpr = [\"+\",2,[\"sin\",\"x\",1]];"]},{"cell_type":"markdown","source":["Although this has demonstrated a couple of issues:"," - The simplified expression looks wrong"," - The simplified derivative looks wrong (although the evaluation of the derivative looks mostly correct, or at least it's 0/positive/negative in the right places)"]},{"cell_type":"markdown","source":["## Back to the expression tree","To try and debug, the odd representation of the testExpr, let's have another look at the tree:"]},{"cell_type":"code","source":["picture1 is [branches,nodecircles,mytexts,idtexts];"]},{"cell_type":"markdown","source":["We can see that on node 2, the combination of 5 and 6 doesn't quite make sense. This indicates a problem with infix. It's to do with unary expressions:"]},{"cell_type":"code","source":["infix is (leftInfix_Or_Empty // nodeValue // rightInfix_Or_Empty)","if not(rightInfix_Or_Empty < 0 && nodeValue == \"+\")","else (leftInfix_Or_Empty // rightInfix_Or_Empty);"]},{"cell_type":"markdown","source":["What if instead of having two sides to sin or cos, I set one side to @?"]},{"cell_type":"code","source":["testExpr = [\"+\",2,[\"sin\",\"x\",@]];"]},{"cell_type":"markdown","source":["Then infix needs to know whether there are one or two operands. By convention, we'll say that:"]},{"cell_type":"code","source":["testExpr = [\"+\",2,[\"sin\",@,\"x\"]];"]},{"cell_type":"markdown","source":["is not valid, it should be the first operand:"]},{"cell_type":"code","source":["testExpr = [\"+\",2,[\"sin\",\"x\",@]];","k = 2;","infix is ","nodeValue // \"(\" // leftInfix_Or_Empty // \")\"","if (subExpr# == 2 || (subExpr# == 3 && subExpr[3] == @)) else","(leftInfix_Or_Empty // nodeValue // rightInfix_Or_Empty)","if not (rightInfix_Or_Empty < 0 && nodeValue == \"+\")","else (leftInfix_Or_Empty // rightInfix_Or_Empty);"]},{"cell_type":"markdown","source":["We should redefine the deriv definitions for Sin and Cos to use this change:"]},{"cell_type":"code","source":["SinDeriv is [\"*\",expr[2][3],[\"cos\",expr[2]]]","if(expr[2][2] == wrt) else","[\"*\", expr[2][2],[\"cos\",expr[2]]] ","if(expr[2][3] == wrt)","else","[\"cos\",expr[2]];"]},{"cell_type":"markdown","source":["The derivative of cos x is -sinx, so the default is to return a * object. However, as above, multiples are dealt with"]},{"cell_type":"code","source":["CosDeriv is [\"*\",-1,[\"*\",expr[2][3],[\"sin\",expr[2]]]]","if(expr[2][2] == wrt) else","[\"*\",-1,[\"*\", expr[2][2],[\"sin\",expr[2]]]] ","if(expr[2][3] == wrt)","else","[\"*\",-1,[\"sin\",expr[2]]];"]},{"cell_type":"markdown","source":["## More test expressions","We can now go back to the graph view:"]},{"cell_type":"code","source":["picture1 is [debugLabels, xaxisline,xticks,yticks,yaxisline,dot,graphdots,mouseXLabel];"]},{"cell_type":"markdown","source":["Let's use some test expressions, click on one to try it:"]},{"cell_type":"code","source":["xmax = 360;","ymax = 5;","ytickinterval = 2;","xtickinterval = 30;","testExpr = [\"+\",2,[\"sin\",\"x\",@]];"]},{"cell_type":"code","source":["xmax = 360;","ymax = 5;","xtickinterval = 30;","ytickinterval = 2;","coeff = 3;","testExpr = [\"+\",2,[\"sin\",[\"*\",coeff,\"x\"]]];"]},{"cell_type":"code","source":["ymax = 100;","xmax = 20;","xtickinterval = 5;","ytickinterval = 20;","testExpr = [\"+\",[\"+\",[\"*\",\"x\",\"x\"],[\"*\",-4,\"x\"]],-10];"]},{"cell_type":"markdown","source":["### Expanding the graph","Let's expand the graph so that the origin can be drawn somewhere else, and add more labels to the graph:"]},{"cell_type":"code","source":["xtick is Line(xtickpos,yoffset-5,xtickpos,yoffset+5);","displayPrecisionX = 2;","displayPrecisionY = 2;","xticklabel is Text(round((canvasXToGraphX with canvasX is xtickpos),displayPrecisionX),xtickpos,yoffset+15,12,\"green\",\"middle centre\");","xticks is [xtick,xticklabel] with i is 0..(int(xmax/xtickinterval));","xtickpos is graphXToCanvasX with graphX is xtickinterval*i;"]},{"cell_type":"markdown","source":["Previously we defined canvasXToGraphX, graphXToCanvasX and graphYToCanvasY, but we didn't define canvasYToGraphY"]},{"cell_type":"code","source":["graphYToCanvasY is yoffset - (yaxisheight/ymax)*graphY;","canvasY is mouseY;","graphY = 1;"]},{"cell_type":"markdown","source":["So to rearrange:"]},{"cell_type":"code","source":["canvasYToGraphY is (yoffset-canvasY)/(yaxisheight/ymax);","yticklabel is Text(round((canvasYToGraphY with canvasY is ytickpos),displayPrecisionY),xoffset-5,ytickpos,12,\"green\",\"middle right\");","ytick is Line(xoffset-5,yoffset,xoffset+5,yoffset);","yticks is [ytick,yticklabel] with i is 0..(int(ymax/ytickinterval));","ytickpos is graphYToCanvasY with graphY is ytickinterval*i;"]},{"cell_type":"markdown","source":["### Adding extra guidelines","It would be good to highlight the currently selected position on the X and Y axis:"]},{"cell_type":"code","source":["curLineV is Line(dotx,doty,dotx,yoffset,\"#bbbbbb\") if dotx < (xoffset + xaxiswidth) else @;","curLineH is Line(dotx,doty,xoffset,doty,\"#bbbbbb\") if doty > (yoffset - yaxisheight) else @;","curXTick is xticklabel with xtickpos is dotx if dotx < (xoffset + xaxiswidth) else @;","curYTick is yticklabel with ytickpos is doty if doty > (yoffset - yaxisheight) else @;","picture1 is [curLineV,curLineH, curXTick,curYTick,debugLabels, xaxisline,yaxisline,","graphdots,mouseXLabel, dot,xticks,yticks];"]},{"cell_type":"markdown","source":["### Moving the axes","At the moment each axis only goes from 0, but it would be good to allow them to go negative:"]},{"cell_type":"code","source":["ymin = -20;","xmin = -10;","xmax = 10;","ymax = 100;","canvasX is mouseX;","dotresolution = 137;","canvasYToGraphY is (yoffset - canvasY) / (yaxisheight / (ymax - ymin)) + ymin;","graphYToCanvasY is yoffset - (yaxisheight/(ymax - ymin))*(graphY-ymin);","canvasXToGraphX is (xmax-xmin)*((canvasX-xoffset)/xaxiswidth) + xmin;","graphXToCanvasX is (xaxiswidth/(xmax-xmin))*(graphX-xmin)+xoffset;","graphdots is dot with mouseXcoord is xmin..(xmax/dotresolution)..xmax, colour is \"red\", dotsize is 2;","xticks is [xtick,xticklabel] with i is (int(xmin/xtickinterval))..(int(xmax/xtickinterval));","yticks is [ytick,yticklabel] with i is (int(ymin/ytickinterval))..(int(ymax/ytickinterval));","xaxisline is Line(xoffset,(graphYToCanvasY with graphY is 0),","xoffset+xaxiswidth,","(graphYToCanvasY with graphY is 0),\"black\");","yaxisline is Line((graphXToCanvasX with graphX is 0),yoffset,","(graphXToCanvasX with graphX is 0),yoffset - yaxisheight,\"black\");","xtick is Line(xtickpos,(graphYToCanvasY with graphY is 0),xtickpos,(graphYToCanvasY with graphY is 0)+10,\"black\");","xticklabel is Text(round((canvasXToGraphX with canvasX is xtickpos),displayPrecisionX),xtickpos,(graphYToCanvasY with graphY is 0)+15,12,\"green\",\"middle centre\");","ytick is Line((graphXToCanvasX with graphX is 0)-10,yoffset,(graphXToCanvasX with graphX is 0),yoffset,\"black\");","yticklabel is Text(round((canvasYToGraphY with canvasY is ytickpos),displayPrecisionY),(graphXToCanvasX with graphX is 0)-15,ytickpos,12,\"green\",\"middle right\");"]},{"cell_type":"markdown","source":["## Gradient Descent","We can now start some basic Stochastic gradient descent experiments","We can start the gradient descent whenever the mouse is clicked, normally this would be a random point, but we can let the user decide to experiment.","","We need a learning rate:"]},{"cell_type":"code","source":["learningrate = 0.2;","stepsize is gradient * learningrate;","randomSample = 90;","gradient is testExpr_d_e with mouseXcoord is randomSample;","","xmax = 5;","xmin = -5;","when(mousePressed == true){","\trandomSample = canvasXToGraphX with canvasX is dotx;","}","randomSample = 6;","","endPoint is randomSample - stepsize;"]},{"cell_type":"code","source":["ymax = 100;","xmax = 8;","xmin = -8;","ymin = -30;","xtickinterval = 5;","ytickinterval = 20;","testExpr = [\"+\",[\"+\",[\"*\",[\"*\",\"x\",\"x\"],3],[\"*\",-3,\"x\"]],5];"]},{"cell_type":"markdown","source":["Although we'd normally terminate when successive steps are within a certain tolerance, for now I'm going to set a finite number of steps"]},{"cell_type":"code","source":["numSteps = 7;","gradientDescentDot is Circle((graphXToCanvasX with graphX is allPoints[i]),","(graphYToCanvasY with graphY is (Eval with expr is testExpr, mouseXcoord is allPoints[i])),4,\"blue\");","gradientDescentLine is Line((graphXToCanvasX with graphX is allPoints[i]),","(graphYToCanvasY with graphY is (Eval with expr is testExpr, mouseXcoord is allPoints[i])),","(graphXToCanvasX with graphX is allPoints[i-1]),","(graphYToCanvasY with graphY is (Eval with expr is testExpr, mouseXcoord is allPoints[i-1])),\"blue\");","gradientDescentDots is gradientDescentDot with i is 1..allPoints#;","gradientDescentLines is gradientDescentLine with i is 2..allPoints#;","nextPoints is [endPoint] if (numSteps == 1) else [endPoint]","// (nextPoints with randomSample is endPoint, numSteps is numSteps - 1);","allPoints is [randomSample] // nextPoints;","picture1 is [curLineV,curLineH, curXTick,curYTick,","debugLabels, xaxisline,yaxisline,","graphdots,mouseXLabel, dot,xticks,yticks,gradientDescentDots,gradientDescentLines,mouseXLabel];"]},{"cell_type":"markdown","source":["## Test by Making Your Own Test Expressions"]},{"cell_type":"code","source":["ymax = 100;","ymin = -30;","xmax = 10;","xmin = -10;","","testExpr = [\"+\",[\"*\",[\"*\",\"x\",\"x\"],0.9],[\"*\",-3,\"x\"]];"]},{"cell_type":"code","source":["ymax = 30;","ymin = -30;","xmax = 5;","xmin = -5;","","testExpr = [\"+\",[\"*\",[\"*\",\"x\",\"x\"],\"x\"],[\"*\",[\"*\",3,\"x\"],\"x\"]]"]},{"cell_type":"code","source":["ymax = 3;","ymin = -3;","xmax = 360;","xmin= -360;","","testExpr = [\"sin\",\"x\",@]"]},{"cell_type":"code","source":["ymax = 3;","ymin = -3;","xmax = 360;","xmin= -360;","","testExpr = [\"cos\",[\"*\",2,\"x\"],@]"]},{"cell_type":"code","source":["ymax = 3;","ymin = -3;","xmax = 25;","xmin= -25;","","testExpr = [\"sin\",[\"*\",\"x\",\"x\"],@]"]}]